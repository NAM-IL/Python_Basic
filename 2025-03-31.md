### [ 2025-03-31(Mon.) ](https://github.com/NAM-IL/Python_Basic/blob/main/2025-03-31.md)

>   [The Python Tutorial (v.3.13) ](https://docs.python.org/3.13/tutorial/index.html)


---

#### 윈도우즈에서 ZED MCP 사용하기
- [Building Zed for Windows](https://zed.dev/docs/development/windows)
- [Zed editor - 협업과 AI 기능이 강화된 아톰 개발자의 에디터](https://tilnote.io/pages/66d860bed51f879a2b001ce1)
- [Installing Zed Editor on Windows](https://www.sousali.com/blog/Installing-Zed-Editor-on-Windows)

---
#### tuple 타입 ── 변경할 수 없는 배결을 다루는 타입


---
#### 딕셔너리 ── 키와 값의 셋을 다룸
##### dict 타입 ── 딕셔너리를 다루는 타입
##### 엘리먼트 추가와 삭제
##### 키를 사용한 엘리먼트로의 접근
##### 키로 사용할 수 있는 객체의 조건
###### 튜플은 변경할 수 없는 객체이므로 키로 사용할 수 있음
    book = ('book',)
    {book: 0}

---
#### for 문에서의 딕셔너리의 동작
```
items = {'note': 1, 'notebook': 2, 'sketchbook': 3}
for key in items:  # 키만 얻음
    print(key)

>>>
    note
    notebook
    sketchbook
```

```
# 키와 값의 튜플을 얻음
for key, value in items.items():
    print(key, value)

>>>
    note 1
    notebook 2
    sketchbook 3
```

---
### List, Dictionary, Tuple, Set


---
#### 집합 ── 유일한 엘리먼트를 모아서 다룸
##### set 타입 ── 변경할 수 있는 집합을 다루는 타입
    - 중복된 엘리먼트를 하로 합침
    - 세트 통과시켜서 중복값 제거

```
# set 타입의 집합을 작성
items = {'note', 'notebook', 'sketchbook'}
type(items)

>>>
    set
```

```
    집합 자료형 관련 함수
    값 1개 추가하기 - add
    이미 만들어진 set 자료형에 값을 추가할 수 있다. 1개의 값만 추가add할 때는 다음과 같이 하면 된다.

    >>> s1 = set([1, 2, 3])
    >>> s1.add(4)
    >>> s1
    {1, 2, 3, 4}
    값 여러 개 추가하기 - update
    여러 개의 값을 한꺼번에 추가(update)할 때는 다음과 같이 하면 된다.

    >>> s1 = set([1, 2, 3])
    >>> s1.update([4, 5, 6])
    >>> s1
    {1, 2, 3, 4, 5, 6}
    특정 값 제거하기 - remove
    특정 값을 제거하고 싶을 때는 다음과 같이 하면 된다.

    >>> s1 = set([1, 2, 3])
    >>> s1.remove(2)
    >>> s1
    {1, 3}
```

- [[Python] 자료구조 - 컨테이너 자료형, 리스트](https://velog.io/@zer0/Python-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8)
- [[ 코랩과 파이썬 ] 3. python 컨테이너 container 자료: list, tuple, set, dictionary ](https://happybigdata.tistory.com/5)
- [[Python] Data Types / Data Structure / Container (List, Tuple, Set, Dictionary) / mutable, immutable / hashable](https://velog.io/@jiggyjiggy/Python-Data-Types-Data-Structure-Container-List-Tuple-Set-Dictionary-mutable-immutable-hashable)

---
### 엘리먼트 추가와 삭제

---



---
#### frozenset 타입 ── 변경할 수 없는 집합을 다루는 타입

# frozenset 타입 집합 작성
    items = frozenset(['note', 'notebook', 'sketchbook'])
    type(items)

    >>>
        frozenset

---
#### 집합 연산 ── 합집합, 차집합, 교집합, 대칭차집합
    set_a = {'note', 'notebook', 'sketchbook'}
    set_b = {'book', 'rulebook', 'sketchbook'}

    set_a | set_b  # 합집합
    >>> {'book', 'note', 'notebook', 'rulebook', 'sketchbook'}

    # 합집합. set.union()으로도 동일하게 구할 수 있음
    set_a.union(set_b)
    >>> {'book', 'note', 'notebook', 'rulebook', 'sketchbook'}

    # 차집합. set.difference()로도 동일하게 구할 수 있음
    set_a - set_b
    >>> {'note', 'notebook'}

    # 교집합. set.intersection()으로도 동일하게 구할 수 있음
    set_a & set_b
    >>> {'sketchbook'}

    # 대칭차집합. set.symmetric_difference()로도 동일하게 구할 수 있음
    set_a ^ set_b
    >>> {'book', 'note', 'notebook', 'rulebook'}

    # 부분 집합 판정. set.issubset()으로도 동일하게 구할 수 있음
    {'note', 'notebook'} <= set_a
    >>> True

---
#### 컴프리헨션 ── 효율적인 시퀀스 생성
###### ⭐ 리스트 컴프리헨션 ── 효율적인 리스트 생성
리스트 컴프리헨션의 문법은 다음과 같다. ‘if 조건문’ 부분은 앞의 예제에서 볼 수 있듯이 생략할 수 있다.
- 빈리스트 만들기

```
[표현식 for 항목 in 반복_가능_객체 if 조건문]
```
```
number = [ str(v) for v in range(10)]
print(number)

>>> ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
```

조금 복잡하지만, for 문을 2개 이상 사용하는 것도 가능하다. for 문을 여러 개 사용할 때의 문법은 다음과 같다.
```
[표현식 for 항목1 in 반복_가능_객체1 if 조건문1
      for 항목2 in 반복_가능_객체2 if 조건문2
      ...
      for 항목n in 반복_가능_객체n if 조건문n]
```

```
number = [
          str(v) for v in range(10) if v % 2 == 0
         ]
print(number)

>>> ['0', '2', '4', '6', '8']
```

```
리스트 = [(lambda item:item*2)(item) for item in range(0, 10) if item % 2 == 0]
print(리스트)

>>> [0, 4, 8, 12, 16]
```

---
### 중첩된 리스트 컴프리헨션
```
리스트2 = [(x, y) for x in [1, 2, 3] for y in [4, 5, 6]]
print(리스트2)

>>> [(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]
```



---
#### 기타 컴프리헨션
```
set_comprehension = {i for i in range(10)}
type(set_comprehension)
>>> set

set_comprehension
>>> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```
```
dict_comprehension = {str(x): x for x in range(3)}
type(dict_comprehension)
>>> dict

dict_comprehension
>>> {'0': 0, '1': 1, '2': 2}
```
```
# 튜플을 컴프리헨션 문법으로 만들면 ~~
gen = (i for i in range(3))
type(gen)
>>> generator

```


---
### 그 외의 타입을 나타내는 개념
- 가변 객체 ── 정의한 뒤 값을 변경할 수 있는 객체
- 불변 객체 ── 정의한 뒤 값을 변경할 수 없는 객체
- 컨테이너 객체 ── 다른 객체에 대한 참조를 가진 객체
- 이터러블 객체 ── for 문에서 사용할 수 있는 객체
- 호출 가능 객체 ── ()를 붙여 호출할 수 있는 객체



---
## 함수 ── 관련된 처리를 모음



---
### 함수 정의와 실행
```
def print_page():  # 함수를 정의함
    print('no content')
```

```
print_page()  # 함수를 실행함

>>> no content

```

---
### 인수를 받는 함수
```
def print_page(content):
    print(content)
```
```
print_page('my contents')  # 인수를 전달해 함수를 실행함

>>> my contents

```

```
# 인수 없이 호출하면 에러가 발생함
print_page()

    >>>
    ---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call last)
    <ipython-input-5-b5fdad0e9b2d> in <module>
          1 # 인수가 없이 호출하면 에러가 발생함
    ----> 2 print_page()

    TypeError: print_page() missing 1 required positional argument: 'content'
```

```
def print_page(content='no content'):
    print(content)

print_page()  # 기본값을 이용함

>>> no content

# 인수를 전달하면 해당 값을 이용함
print_page('my contents')

>>> my contents


```


---
## 함수는 객체

---

---
## 함수의 다양한 인수
### 위치만 인수로 가짐 ── 호출 시 가인수 이름을 지정할 수 없는 인수




---
### 키워드 인수 ── 가인수 이름을 지정해 실인수를 전달함
```
def increment(page_num, last):
    next_page = page_num + 1
    if next_page <= last:
        return next_page
    raise ValueError('Invalid arguments')
```

    # 키워드 인수를 사용한 함수 호출
    increment(page_num=2, last=10)

    # 순서를 바꾸어도 결과는 같음
    increment(last=10, page_num=2)

    increment(page_num=2, last=10, unknown=0)


---




---
#### 기본값의 함정
```
from datetime import datetime
```

```
# 기본값의 잘못된 사용 예시
def print_page(content, timestamp=datetime.now()):
    print(content)
    print(timestamp)
```





---
### ⭐ 길이가 변하는 위치 인수
```
# 길이가 변하는 위치 인수를 받음
def print_pages(content, *args):
    print(content)
    for more in args:
        print('more:', more)
```



---
### ⭐ 길이가 변하는 키워드 인수
```
# 길이가 변하는 키워드 인수를 받음
def print_page(content, **kwargs):  <- ** 딕셔너리
    print(content)
    for key, value in kwargs.items():
        print(f'{key}: {value}')
```

```
print_page('my content', published=2019,
           author='rei suyama')


>>> 
    my content
    published: 2019
    author: rei suyama
```

```
# 어떤 호출에도 대응함
def print_pages(*args, **kwargs):
    for content in args:
        print(content)
    for key, value in kwargs.items():
        print(f'{key}: {value}')

print_pages('content1', 'content2', 'content3',
            published=2019, author='rei suyama')

>>>
    content1
    content2
    content3
    published: 2019
    author: rei suyama
```

---


---
### 인수 리스트 언팩 ── 리스트나 딕셔너리에 저장된 값을 인수로 전달
    def print_page(one, two, three):
        print(one)
        print(two)
        print(three)

---
#### 함수의 독스트링

---
### lambda 식 ── 이름이 없는 함수

    lambda x : x*2
        
        ⬇️
    
    def 함수명(x):
        return x*2
---
### 함수를 인자로 받는 가장 대표적인 클래스
- import reduce
- map - for문을 돌리지말고 map
- filter


#### 첫 번째 인수의 함수가 참이 되는 것만 남음
```
def asdf(x):

```

```
# 필터는 통과하고 나면 크기가 줄어든다.
# True 인것만 모아서 새로운 객체를 만들어 준다.
nums = range(0, 10)
filtered = filter(lambda x : x ==3, nums)

print(type(filtered))
>>> <class 'filter'>

print(list(filtered))
>>> [3]

```

---
### ⭐ 타입 힌트 ── 어노테이션을 사용해 함수에 타입 정보 부여
### 타입 정보를 부여함으로써 얻을 수 있는 장점
```
# Optional은 None의 가능성이 있을 때 이용함
from typing import Optional
```

# 베리언트 2가지 Ok(int), Error(e)
```
def increment(
    page_num: int,
    last: int,
    *,
    ignore_error: bool = False) -> Optional[int]: # <- 시그니쳐(함수명), 컨텍스트(body) ->
    next_page = page_num + 1
    if next_page <= last:
        return next_page
    if ignore_error:
        return None
    raise ValueError('Invalid arguments')

```

```
increment.__annotations__  # 타입 정보가 저장되어 있음

>>>
    {'page_num': int,
     'last': int,
     'ignore_error': bool,
     'return': typing.Union[int, NoneType]}
```

```
anno = increment.__annotations__  # 타입 정보가 저장되어 있음
    print(anno)

>>>
    {'page_num': <class 'int'>, 'last': <class 'int'>, 'ignore_error': <class 'bool'>, 'return': typing.Optional[int]}
```

---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---


---

