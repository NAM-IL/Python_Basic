### [ 2025-04-01(Tue.) ](https://github.com/NAM-IL/Python_Basic/blob/main/2025-04-01.md)

>   [The Python Tutorial (v.3.13) ](https://docs.python.org/3.13/tutorial/index.html)

- [Helix](https://helix-editor.com/) - A post-modern text editor.
    - [Install helix on macOS with MacPorts](https://ports.macports.org/port/helix/)
---
# 07-modules

# 08-built-in-functions-and-dunder-methods

### 내장 함수 ── 항상 이용할 수 있는 함수
### 객체 타입을 조사하는 함수
##### isinstance()、issubclass() ── 동적 타입 판정
```
d = {}  # 빈 딕셔너리 생성

# 첫 번째 인수는 인스턴스 객체
isinstance(d, dict)
>>> True

isinstance(d, object)
>>> True

isinstance(d, (list, int, dict))
>>> True


# 첫 번째 인수는 클래스 객체
issubclass(dict, object)
>>> True


# bool 타입은 int 타입의 서브 클래스
issubclass(bool, (list, int, dict))
>>> True


```




---
#### 추상메서드
#### 추상클래스 : 추상메서드가 하나라도 있으면 추상클래스

#### 모든것을 다 추상메서드를 만든것을 인터페이스(트레이트)
```
class Klass {
    function asdf() { }
}
```
추상클래스 눈에 안보이는 것

시니처만 있고 컨텍스트가 없는 것(body가 없는 것)
정의만 있고 본문바디가 없는 것


---
### callable() ── 객체의 호출 가능 여부 판정

```
callable(''.split)  # 메서드
```


```
경로1 = "/Volumes/DATA/Workspace_Python/Python_Basic/fulfillPython-main/08-built-in-functions-and-dunder-methods/interactive.ipynb"

경로들 = 경로1.split("/")

print(f"경로들:{경로들}")
>>> 경로들:['', 'Volumes', 'DATA', 'Workspace_Python', 'Python_Basic', 'fulfillPython-main', '08-built-in-functions-and-dunder-methods', 'interactive.ipynb']

print(f"확장자: {경로들[-1].split('.')[1]}")
>>> 확장자: ipynb

```


```
class Threshold:
    def __init__(self, threshold):
        self.threshold = threshold

    # 메서드 오버라이드
    def __call__(self, x):
        return self.threshold < x
```

```
threshold = Threshold(2)

# __call__() 메서드가 호출됨
threshold(3)
>>> True

callable(threshold)
>>> True
```
### 객체 속성에 관함 함수
### hasattr() ── 객체의 속성 유무 판정
```
import json
import os
```

```
# 모듈 객체는 반드시 __file__을 가짐
# py파일이 모여있다.
# 모듈들이 모여있고, __init__.py 가 있으면 패키지
hasattr(json, '__file__')
>>> True
```

```

# 패키지 객체는 반드시 __path__를 가짐
def is_package(module_or_package):
    return hasattr(module_or_package, '__path__')
```

```
# json 모듈은 패키지
is_package(json)
>>> True
```

```
# os 모듈은 단일 파일
is_package(os)
>>> False
```


#### LBYL 스타일과 EAFP 스타일
- [[python] LBYL와 EAFP](https://straw961030.tistory.com/177)

### getattr(), setattr(), delattr() ── 객체 속성 조작
```
class Mutable:
    def __init__(self, attr_map):
        # 딕셔너리의 키를 속성 이름으로 한 인스턴스 변수를 준비
        for k, v in attr_map.items():
            setattr(self, str(k), v)
```

```
m = Mutable({'a': 1, 'b': 2})
m.a
>>> 1

m.b
>>> 2

getattr(m, 'a')
>>> 1

delattr(m, 'a')
m.a
>>>
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-31-f0b741c52f94> in <module>
----> 1 m.a

AttributeError: 'Mutable' object has no attribute 'a'
```


### 이터러블한 객체를 받는 함수
### zip() ── 다수의 이터러블 엘리먼트를 동시에 반환

```
x = [1, 2, 3]
y = [4, 5, 6]
```

```
zip(x, y)
>>> <zip at 0x7f84e027bac0>
```


```
# 내용을 확인하기 위해 리스트로 변환
list(zip(x, y))
>>> [(1, 4), (2, 5), (3, 6)]
```

```
x = [1, 2, 3]
y = [4, 5, 6, 7]
z = [8, 9]
```

```
# 짧은 이터러블 길이로 만듬
list(zip(x, y, z))

>>>[(1, 4, 8), (2, 5, 9)]
```


```
# fillvalue는 부족한 값을 메꿀 때 사용됨
from itertools import zip_longest
list(zip_longest(x, y, z, fillvalue=0))

>>> [(1, 4, 8), (2, 5, 9), (3, 6, 0), (0, 7, 0)]
```


### sorted() ── 이터러블 엘리먼트를 정렬
### 오름차순 asc (1:상단 -> 10:하단)
### 내림차순 desc (10:상단 -> 1:하단)
```
x = [1, 4, 3, 5, 2]
y = [1, 4, 3, 5, 2]
```

```
# list.sort()는 자신을 정렬함
# 파괴적 메소드? or 비파괴 메서드?
x.sort() # 원본 데이터가 변경됨 -> 파괴적 메소드
x
>>> [1, 2, 3, 4, 5]
```

```
# sorted()는 새로운 리스트를 반환함
sorted(y)
>>> [1, 2, 3, 4, 5]
```

```
y
>>> [1, 4, 3, 5, 2]

# reverse=True를 지정하면 역순이 됨
sorted(y, reverse=True)
>>> [5, 4, 3, 2, 1]
```


```
#비교 결과가 같으면 원래 순서를 유지함
x = ['1', '4', 3, 1, '1']

#각 엘리먼트를 int 타입값으로 비교
sorted(x, key=lambda v: int(v))
>>> ['1', 1, '1', 3, '4']
```

join() 내장함수
쿼리스트링 GET 방식으로 데이터를 전달하는 메소리

### map() ── 모든 엘리먼트에 함수를 적용
```
x = (1, 4, 3, 5, 2) # 튜플자료

# map(함수자리, 이터러블객체)
map(lambda i: i * 10, x)

list(map(lambda i: i * 10, x))
>>> [10, 40, 30, 50, 20]
```

```
keys = ('q','limit','page')
values = ('python', 10, 2)
```

```
# 함수가 받는 인수의 값과 전달되는 이터러블의 값을 일치시킴
list(map(lambda k, v: f'{k}={v}', keys, values))
>>> ['q=python', 'limit=10', 'page=2']
```

```
https://www.google.com/search?q=python&rlz=1C5MACD_enKR1141KR1141&oq=python&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIGCAEQRRg7MgYIAhBFGDsyBggDEEUYOzIGCAQQRRg8MgYIBRBFGDwyBggGEEUYPDIGCAcQRRhB0gEINTk4M2owajeoAgCwAgA&sourceid=chrome&ie=UTF-8
```

```
# join()과 조합해 쿼리 문자열을 작성
'?' + '&'.join(
    map(lambda k, v: f'{k}={v}', keys, values))
```

```
키들 = ["a", "b", "c", "d"]
벨류들 = ["a", "b", "c", "d"]
딕셔너리 = {}

for _, (k,v) in enumerate(zip(키들, 벨류들)):
    딕셔너리[k] = v

# join()과 조합해 쿼리 문자열을 작성
def 쿼리스트링만들기(**딕셔너러):
    keys = 딕셔너러.keys()
    values = 딕셔너러.values()
    결과 = "?" + '&'.join(
        map(lambda k, v : f'{k}={v}', keys, values)
    )

    return list(결과)

만들어진결과 = 쿼리스트링만들기(**딕셔너리)
print(만들어진결과)
>>> ['?', 'a', '=', 'a', '&', 'b', '=', 'b', '&', 'c', '=', 'c', '&', 'd', '=', 'd']

결과문자열 = ''

for 문자열 in 만들어진결과:
    결과문자열 += 문자열

print(결과문자열)
>>> ?a=a&b=b&c=c&d=d
```

### filter() ── 이터러블한 엘리먼트를 필터링
```
x = (1, 4, 3, 5, 2)
filter(lambda i: i > 3, x)
```

```
# filter
x = (1, 4, 3, 5, 2)

def 크기확인(a):
    if a > 3:
        return True
    else:
        return False

ret = list(filter(크기확인, x))
print(ret)
>>> [4, 5]
```

- [[Python] reduce() 함수 사용법](https://python101.tistory.com/entry/Python-reduce-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%EB%B2%95)
    - reduce(function, sequence[, initial])
        - sequence의 첫 번째 원소와 initial 값을 가지고 function 함수를 호출합니다.
        - function 함수의 반환값과 sequence의 다음 원소를 가지고 다시 function 함수를 호출합니다.
        - 이 과정을 sequence의 모든 원소에 대해 반복합니다.

```
from functools import reduce

def 누적합(a, b):
    return a+b

nums = [1, 2, 3, 4, 5]

# reduce(function, sequence[, initial])
result = reduce(누적합, nums)
result = reduce(lambda a, b : a + b, nums)
print(result)
>>> 15
```

#### sorted()와 조합하면 편리한 operator 모듈
```
# itemgetter의 동작을 확인
from operator import itemgetter
d = {'word': 'python', 'count': 3}
```

```
f = itemgetter('count')
f(d)  # d['count']를 반환함
>>> 3
```

```
f = itemgetter('count', 'word')
f(d)  # (d['count'], d['word'])를 반환함
>>> (3, 'python')
```

### all()、any() ── 논리값 반환


## 기타 내장 함수
### 특수 메서드 ── 파이썬이 암묵적으로 호출하는 특별한 메서드
### 속성으로의 동적 엑세스
### \_\_setattr\_\_() ── 속성 대입 시 호출됨
```
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __setattr__(self, name, value):
        if name not in ('x', 'y'):
            raise AttributeError('Not allowed')
        super().__setattr__(name, value)
```

### \_\_delattr\_\_() ── 속성 삭제 시 호출됨

### \_\_getattr\_\_()、\_\_getattribute\_\_() ── 속성에 접근 시 호출됨

### \_\_bool\_\_() ── 객체를 논리값으로 평가함

## \_\_call\_\_() ── 인스턴스를 함수처럼 다룸
```
class Adder:
    def __init__(self):
        self._values = []
    def add(self, x):
        self._values.append(x)
    def __call__(self):
        return sum(self._values)
```

```
adder = Adder()
adder.add(1)
adder.add(3)
adder()
>>> 4
```

```
adder.add(5)
adder()
>>> 9
```


## 속성으로의 동적 엑세스
### \_\_setattr\_\_() ── 속성 대입 시 호출됨
```
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __setattr__(self, name, value):
        if name not in ('x', 'y'):
            raise AttributeError('Not allowed')
        super().__setattr__(name, value)
```

import json
class Config:
    def __init__(self, filename):
        self.config = json.load(open(filename))
    def __getattr__(self, name):
        if name in self.config:
            return self.config[name]
        # 존재하지 않는 설정값으로의 엑세스 시 에러
        raise AttributeError()


## 이터러블한 객체로서 동작
### m\_\_iter\_\_() ── 이터레이터 객체 반환
```
class Iterable:
    def __init__(self, num):
        self.num = num
    def __iter__(self):
        return iter(range(self.num))
```


```
[val for val in Iterable(3)]

[0, 1, 2]
```


### \_\_next\_\_() ── 다음 엘리먼트 반환
```
class Reverser:
    def __init__(self, x):
        self.x = x
    def __iter__(self):
        return self
    def __next__(self):
        try:
            return self.x.pop()
        except IndexError:
            raise StopIteration()
```

```
[val for val in Reverser([1, 2, 3])]
>>> [3, 2, 1]
```

### \_\_contains\_\_() ── 객체 유무 판정